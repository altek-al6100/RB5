/*
 * File:  altek_state.c
 * Description: FSM
 *
 * Copyright 2019-2030  Altek Semiconductor Corporation
 *
 */

/*
 * this file was generated by NunniFSMGen
 */

/*
 * This file is part of al6100.
 *
 * al6100 is free software: you can redistribute it and/or modify it under
 * the terms of the GNU General Public License version 2, as published by
 * the Free Software Foundation.
 *
 * al6100 is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTIBILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License version 2 for
 * more details.
 *
 * You should have received a copy of the General Public License version 2
 * along with al6100. If not, see https://www.gnu.org/licenses/gpl-2.0.html.
 */

#include <linux/init.h>
#include <linux/module.h>
#include <linux/ioctl.h>
#include <linux/fs.h>
#include <linux/device.h>
#include <linux/err.h>
#include <linux/list.h>
#include <linux/errno.h>
#include <linux/mutex.h>
#include <linux/slab.h>
#include <linux/wait.h>
#include <linux/sched.h>
#include <linux/kthread.h>
#include <linux/spi/spi.h>
#include <linux/io.h>
#include <linux/dma-mapping.h>
#include <linux/version.h>
#include <linux/proc_fs.h>
#include <linux/gpio.h>
#include <linux/interrupt.h>
#include <linux/delay.h>
#include <asm/segment.h>
#include <linux/uaccess.h>
#include <linux/buffer_head.h>
#include <linux/of_gpio.h>
#include <linux/regulator/consumer.h>
#include <linux/clk.h>
#include <linux/pinctrl/consumer.h>

#include "include/altek_state.h"
#include "include/error/altek_state_err.h"
#include "include/miniisp.h"
#include "include/miniisp_ctrl.h"
#include "include/ispctrl_if_master.h"
#include "include/ispctrl_if_master_local.h"
#include "include/miniisp_customer_define.h"

#define MINI_ISP_LOG_TAG	"[[miniisp]altek_state]"


int state_open(void *o)
{
	int ret = 0;
	/* add your code hereafter... */
	ret = mini_isp_power_open();

	return ret;
}


int error_sequence(void *o)
{
	/* add your code hereafter... */
	return ERR_MINIISP_STATE_ERROR_SEQUENCE;
}


int redundant_sequence(void *o)
{
	/* add your code hereafter... */
	return ERR_MINIISP_STATE_REDUNDANT_SEQUENCE;
}


int state_enter_hwpt(void *o)
{
	int ret = 0;

	misp_info("%s S", __func__);
	/* add your code hereafter... */
	/*check bypass mode be set or not*/
	/*if yes, leave bypass mode*/
	mini_isp_check_and_leave_bypass_mode();
	/*Pure bypass by sensor*/
	ret = mini_isp_pure_bypass((*(u16 *)o));
	return ret;
}


int state_write_basic_code(void *o)
{
	errcode ret = ERR_SUCCESS;
	struct transferdata *fsm_param = o;

	misp_info("%s S", __func__);
	if (fsm_param->opcode == ISPCMD_BULK_WRITE_BASICCODE) {
		ret = mast_bulk_data_cmd_write_basic_code(
					fsm_param->devdata,
					fsm_param->data);
	} else if (fsm_param->opcode == ISPCMD_BULK_WRITE_BASICCODE_CODESUM) {
		ret = mast_bulk_data_cmd_write_basic_code_shortlen(
					fsm_param->devdata,
					fsm_param->data);
	} else
		ret = ERR_MINIISP_STATE_ERROR_PARAM;

	return ret;
}


int state_close(void *o)
{
	int ret = 0;

	misp_info("%s S", __func__);
	ret = mini_isp_power_close();
	return ret;
}


int state_leave_hwpt(void *o)
{
	/* add your code hereafter... */
	/*check bypass mode be set or not*/
	/*if yes, leave bypass mode*/
	mini_isp_check_and_leave_bypass_mode();
	return 0;
}


int state_scenario_chg(void *o)
{

	errcode ret = ERR_SUCCESS;
	struct transferdata *fsm_param = o;

	misp_info("%s S", __func__);
	ret = mast_camera_profile_cmd_set_sensor_mode(
					fsm_param->devdata,
					fsm_param->opcode,
					fsm_param->data);

	return ret;
}


int state_strm_on_off(void *o)
{
	errcode ret = ERR_SUCCESS;
	struct transferdata *fsm_param = o;

	misp_info("%s S", __func__);
	ret = mast_camera_profile_cmd_set_output_format(
					fsm_param->devdata,
					fsm_param->opcode,
					fsm_param->data);

	return ret;
}


int state_enter_cp(void *o)
{
	errcode ret = ERR_SUCCESS;
	struct transferdata *fsm_param = o;

	misp_info("%s S", __func__);
	ret = mast_camera_profile_cmd_set_cp_mode(
					fsm_param->devdata,
					fsm_param->opcode,
					fsm_param->data);

	return ret;
}


int state_set_qp(void *o)
{
	errcode ret = ERR_SUCCESS;
	struct transferdata *fsm_param = o;

	misp_info("%s S", __func__);
	if (fsm_param->opcode == ISPCMD_BASIC_SET_DEPTH_3A_INFO)
		mast_basic_setting_cmd_set_depth_3a_info(
					fsm_param->devdata,
					fsm_param->opcode,
					fsm_param->data);
	else if (fsm_param->opcode == ISPCMD_CAMERA_SET_AE_STATISTICS)
		ret = mast_basic_setting_cmd_set_ae_statistics(
					fsm_param->devdata,
					fsm_param->opcode,
					fsm_param->data);
	else
		ret = ERR_MINIISP_STATE_ERROR_SEQUENCE;

	return ret;
}


int state_stop(void *o)
{
	errcode ret = ERR_SUCCESS;
	struct transferdata *fsm_param = o;

	misp_info("%s S", __func__);
	ret = mast_camera_profile_cmd_set_sensor_mode(
					fsm_param->devdata,
					fsm_param->opcode,
					fsm_param->data);

	return ret;
}


int state_leave_cp(void *o)
{
	int err = 0;
	struct transferdata *fsm_param = o;

	misp_info("%s S", __func__);
	err = mini_isp_leave_cp(fsm_param->opcode, fsm_param->data);
	return err;
}


int state_leave_cp_standy(void *o)
{
	int err = 0;

	misp_info("%s S", __func__);
	err = mini_isp_leave_cp_standby();
	return err;
}
